package game

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"regexp"
	"strconv"
	"strings"
	"testing"
	"text/template"
)

func Test_codegen_rpc_dispatch(t *testing.T) {
	b, e := ioutil.ReadFile("../protocol/msg/msg.go")
	if e != nil {
		t.Error(e)
	}

	type func_def struct {
		Seq     int
		Name    string
		ArgType string
		RetType string
	}
	type rpc_def struct {
		Funcs []func_def
	}

	m := rpc_def{Funcs: []func_def{}}
	var msg_def = regexp.MustCompile(`^\s+C_(\w+)\s+= (\w+)$`)
	for _, line := range strings.Split(string(b), "\n") {
		if msg_def.Match([]byte(line)) {
			name := msg_def.FindStringSubmatch(line)[1]
			seq, err := strconv.Atoi(msg_def.FindStringSubmatch(line)[2])
			if err != nil {
				t.Error(err)
			}
			m.Funcs = append(m.Funcs, func_def{
				Seq:     seq,
				Name:    name,
				ArgType: name + "Request",
				RetType: name + "Response",
			})

		}
	}

	// fmt.Println(m)

	tpl_rpc_x, e := template.New("").Parse(`package game

import (
	"gitlab.com/megatech/serverex/apps/excalibur/protocol/msg"
)

func (g *GameService) {{.Name}}(req *msg.Request, arg *msg.{{.ArgType}}) *msg.{{.RetType}} {
	return &msg.{{.RetType}}{}
}
`)
	if e != nil {
		t.Error(e)
	}

	rpcs := func() map[string]string {

		path := "."
		dic := map[string]string{}

		dir, err := ioutil.ReadDir(path)
		if err != nil {
			t.Error(err)
		}

		for _, f := range dir {

			if f.IsDir() {
				continue
			}
			if strings.HasPrefix(f.Name(), "rpc_x_") {

				names := strings.Split(f.Name(), "_")
				name := names[3]
				if len(names) > 4 {
					name = name + "_" + names[4]
				}
				name = strings.TrimSuffix(name, ".go")
				dic[name] = f.Name()
			}
		}

		return dic
	}()

	// fmt.Println(rpcs)

	for _, v := range m.Funcs {

		newname := fmt.Sprintf("rpc_x_%d_%s.go", v.Seq, v.Name)
		oldname, exist := rpcs[v.Name]

		if exist {
			os.Rename(oldname, newname)
		} else {

			buf := bytes.NewBuffer([]byte{})
			e := tpl_rpc_x.Execute(buf, v)
			if e != nil {
				t.Error(e)
			}

			dst, err := format.Source(buf.Bytes())
			if err != nil {
				t.Error(err)
			}

			e = ioutil.WriteFile(newname, dst, 0644)
			if e != nil {
				t.Error(e)
			}
		}

	}

	tpl_rpc_dispatch, e := template.New("").Parse(`/// Code generated by msg.go; DO NOT EDIT.

package game

import (
	"github.com/json-iterator/go"
	"gitlab.com/megatech/serverex/apps/excalibur/protocol/msg"
)

func (g *GameService) rpc_dispatch(req *msg.Request) *msg.Response {
	
	switch req.Code {
{{range .Funcs}}
	case msg.C_{{.Name}}:
		arg := &msg.{{.ArgType}}{}
		err := jsoniter.UnmarshalFromString(req.Data, &arg)
		if err != nil {
			return msg.Err(req, msg.ErrDecoding, err.Error())
		}
		res := g.{{.Name}}(req, arg)
		if res.Err != msg.Success {
			return msg.Err(req, res.Err, errcode_to_string(res.Err))
		}
		return msg.OK(req, res)
{{end}}
	default:
		return msg.Err(req, msg.ErrNotImplemented, errcode_to_string(msg.ErrNotImplemented))
	}
}
`)
	if e != nil {
		t.Error(e)
	}

	buf := bytes.NewBuffer([]byte{})
	e = tpl_rpc_dispatch.Execute(buf, m)
	if e != nil {
		t.Error(e)
	}

	dst, err := format.Source(buf.Bytes())
	if err != nil {
		t.Error(err)
	}

	e = ioutil.WriteFile("rpc_dispatch.go", dst, 0644)
	if e != nil {
		t.Error(e)
	}

}
