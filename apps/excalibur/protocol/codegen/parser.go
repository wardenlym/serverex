package codegen

import (
	"bytes"
	"fmt"
	"go/format"
	"regexp"
	"strconv"
	"text/template"
)

type Defs struct {
	Msg EnumDef
	Err EnumDef
	Odm []StructDef
	Rpc []StructDef
}

type EnumCodeDef struct {
	Code              int
	Name              string
	Comment           string
	FormatedForCsharp string
}

type EnumDef struct {
	Namespace string
	Name      string
	Fields    []EnumCodeDef
}

type StructFieldDef struct {
	Name           string
	Type           string
	Tag            string
	CsharpFieldDef string
	Comment        string
}

type StructDef struct {
	Namespace string
	Name      string
	Inherit   string
	Override1 string
	Fields    []StructFieldDef
}

func new_interp() *interp {
	return &interp{
		ret: Defs{
			Msg: EnumDef{Fields: []EnumCodeDef{}},
			Err: EnumDef{Fields: []EnumCodeDef{}},
			Odm: []StructDef{},
			Rpc: []StructDef{},
		},
	}
}

type interp struct {
	index       int
	namespace   string
	enum        string
	ret         Defs
	struct_name string

	in_enum   bool
	in_struct bool

	src_odm_golang     string
	src_odm_csharp     string
	src_msg_golang     string
	src_msg_csharp     string
	src_request_golang string
	src_request_csharp string
	src_rpc_csharp     string
}

// 通过正则,识别出定义类型,实现一个简单的自动机逐行的把协议定义 解析成语言结构定义
func (p *interp) emit(no int, line string) {

	// var empty_reg = regexp.MustCompile(`^(\S+).*$`)
	// var no_reg = regexp.MustCompile(`^}$`)
	var ns_reg = regexp.MustCompile(`^// namespace (\w+)$`)
	var enum_reg = regexp.MustCompile(`^const \( // enum (\w+) from (\w+)$`)
	var enum_field_reg = regexp.MustCompile(`^\s+(\w+)$`)
	var enum_field_reg_with_comment = regexp.MustCompile(`^\s+(\w+)\s+//\s+(.+)$`)

	var struct_reg = regexp.MustCompile(`^type (\w+) struct {$`)
	var struct_field_reg = regexp.MustCompile(`^\s+(\w+)\s+(\S+)$`)

	if ns_reg.Match([]byte(line)) {
		ss := ns_reg.FindStringSubmatch(line)
		println(no, "ns_reg", ss[1])

		p.namespace = ss[1]

	} else if enum_reg.Match([]byte(line)) {
		ss := enum_reg.FindStringSubmatch(line)
		println(no, "enum_reg", ss[1], ss[2])
		from, _ := strconv.Atoi(ss[2])
		p.index = from
		p.in_enum = true
		if ss[1] == "Msg" {
			p.enum = "Msg"
			p.ret.Msg.Namespace = p.namespace
			p.ret.Msg.Name = "Msg"
			fmt.Printf("######## 1 %v\n", p.ret.Msg)
		} else if ss[1] == "Err" {
			p.enum = "Err"
			p.ret.Err.Namespace = p.namespace
			p.ret.Err.Name = "Err"
			fmt.Printf("######## 2 %v\n", p.ret.Msg)
		}

	} else if p.in_enum && enum_field_reg_with_comment.Match([]byte(line)) {
		ss := enum_field_reg_with_comment.FindStringSubmatch(line)
		println(no, "enum_field_reg_with_comment", ss[1])

		if p.enum == "Msg" {
			p.ret.Msg.Fields = append(p.ret.Msg.Fields,
				EnumCodeDef{
					Code:    p.index,
					Name:    ss[1],
					Comment: ss[2],
				})

			p.index++
		} else if p.enum == "Err" {
			p.ret.Err.Fields = append(p.ret.Err.Fields,
				EnumCodeDef{
					Code:    p.index,
					Name:    ss[1],
					Comment: ss[2],
				})
			p.index++
		}

	} else if p.in_enum && enum_field_reg.Match([]byte(line)) {
		ss := enum_field_reg.FindStringSubmatch(line)
		println(no, "enum_field_reg", ss[1])

		if p.enum == "Msg" {
			p.ret.Msg.Fields = append(p.ret.Msg.Fields,
				EnumCodeDef{
					Code: p.index,
					Name: ss[1],
				})

			p.index++
		} else if p.enum == "Err" {
			p.ret.Err.Fields = append(p.ret.Err.Fields,
				EnumCodeDef{
					Code: p.index,
					Name: ss[1],
				})
			p.index++
		}
	} else if struct_reg.Match([]byte(line)) {
		ss := struct_reg.FindStringSubmatch(line)
		println(no, "struct_reg", ss[1])
		p.in_struct = true
		p.in_enum = false
		if p.namespace == "rpc" {
			p.ret.Rpc = append(p.ret.Rpc, StructDef{
				Namespace: p.namespace,
				Name:      ss[1],
				Fields:    []StructFieldDef{},
			})
		} else if p.namespace == "odm" {
			p.ret.Odm = append(p.ret.Odm, StructDef{
				Namespace: p.namespace,
				Name:      ss[1],
				Fields:    []StructFieldDef{},
			})
		}

	} else if p.in_struct && struct_field_reg.Match([]byte(line)) {
		ss := struct_field_reg.FindStringSubmatch(line)
		println(no, "struct_field_reg", ss[1], ss[2])

		if p.namespace == "rpc" {
			p.ret.Rpc[len(p.ret.Rpc)-1].Fields = append(p.ret.Rpc[len(p.ret.Rpc)-1].Fields,
				StructFieldDef{
					Name: ss[1],
					Type: ss[2],
				},
			)
		} else if p.namespace == "odm" {
			p.ret.Odm[len(p.ret.Odm)-1].Fields = append(p.ret.Odm[len(p.ret.Odm)-1].Fields,
				StructFieldDef{
					Name: ss[1],
					Type: ss[2],
				},
			)
		}
	} else {
		//println(no, "miss:", line)
	}

}

// 根据协议定义生成go/c#的代码文本
func (p *interp) complie() Defs {

	func() { // msg golang

		tpl_txt := `/// Code generated by protocol.def.go; DO NOT EDIT.

package msg
	
type Code = int

const (
{{range .Msg.Fields}}    C_{{.Name}} = {{.Code}}
{{end}})

var Code_To_String = map[Code]string{
{{range .Msg.Fields}}    C_{{.Name}} : "{{.Name}}",
{{end}}}

const (
{{range .Err.Fields}}    {{.Name}} = {{.Code}}
{{end}})

var ErrCode_To_String = map[ErrCode]string{
	{{range .Err.Fields}}    {{.Name}} : "{{.Name}}",
	{{end}}}

`
		tpl, e := template.New("msg").Parse(tpl_txt)
		if e != nil {
			panic(e)
		}

		source := bytes.NewBuffer([]byte{})
		e = tpl.Execute(source, p.ret)
		fmt.Println(string(source.Bytes()))
		dst, err := format.Source([]byte(source.Bytes()))
		if err != nil {
			panic(err)
		}

		p.src_msg_golang = string(dst)
	}()

	func() { // msg csharp

		p.ret.Msg = format_enum_for_csharp(p.ret.Msg)
		p.ret.Err = format_enum_for_csharp(p.ret.Err)

		tpl_txt := `/// Code generated by protocol.def.go; DO NOT EDIT.
namespace Network.sdk.Excalibur.Protocol
{
	public sealed partial class Msg
	{
		public enum Code : int
		{
{{range .Msg.Fields}}            {{.FormatedForCsharp}}
{{end}}        }

		public enum Err : int
		{
{{range .Err.Fields}}            {{.FormatedForCsharp}}
{{end}}        }
	}
}
`
		tpl, e := template.New("msg_csharp").Parse(tpl_txt)
		if e != nil {
			panic(e)
		}

		source := bytes.NewBuffer([]byte{})
		e = tpl.Execute(source, p.ret)
		fmt.Println(string(source.Bytes()))
		p.src_msg_csharp = string(source.Bytes())
	}()

	func() { // odm golang

		for i, v := range p.ret.Odm {
			for j, w := range v.Fields {
				name := lowercase_first(w.Name)

				tag := "`" + `json:"` + name + `" bson:"` + name + `"` + "`"
				p.ret.Odm[i].Fields[j].Tag = tag
			}
		}

		tpl_txt := `/// Code generated by protocol.def.go; DO NOT EDIT.

package odm

{{range .}}
type {{.Name}} struct {
{{range .Fields}}    {{.Name}} {{.Type}} {{.Tag}} {{.Comment}}
{{end}}}
{{end}}
`
		tpl, e := template.New("odm").Parse(tpl_txt)
		if e != nil {
			panic(e)
		}

		source := bytes.NewBuffer([]byte{})
		e = tpl.Execute(source, p.ret.Odm)

		dst, err := format.Source([]byte(source.Bytes()))
		if err != nil {
			panic(err)
		}

		p.src_odm_golang = string(dst)
	}()

	func() { // odm csharp

		for i, v := range p.ret.Odm {
			for j, w := range v.Fields {
				p.ret.Odm[i].Fields[j].CsharpFieldDef = parse_go_struct_field_to_csharp_class_field(w.Type, w.Name)
			}
		}

		tpl_txt := `/// Code generated by protocol.def.go; DO NOT EDIT.

using System.Collections.Generic;

namespace Network.sdk.Excalibur.Protocol
{
{{range .}}    public class {{.Name}}
    {
{{range .Fields}}    {{.CsharpFieldDef}}
{{end}}    }

{{end}}}
`
		tpl, e := template.New("odm_charp").Parse(tpl_txt)
		if e != nil {
			panic(e)
		}

		source := bytes.NewBuffer([]byte{})
		e = tpl.Execute(source, p.ret.Odm)

		p.src_odm_csharp = string(source.Bytes())
	}()

	func() { // request golang

		for i, v := range p.ret.Rpc {
			for j, w := range v.Fields {
				name := lowercase_first(w.Name)

				tag := "`" + `json:"` + name + `"` + "`"
				p.ret.Rpc[i].Fields[j].Tag = tag
			}
		}

		tpl_txt := `/// Code generated by protocol.def.go; DO NOT EDIT.

package msg

import "gitlab.com/megatech/serverex/apps/excalibur/protocol/odm"

{{range .}}
type {{.Name}} struct {
    Err ErrCode
{{range .Fields}}    {{.Name}} {{.Type}} {{.Tag}} {{.Comment}}
{{end}}}
{{end}}
`
		tpl, e := template.New("request").Parse(tpl_txt)
		if e != nil {
			panic(e)
		}

		source := bytes.NewBuffer([]byte{})
		e = tpl.Execute(source, p.ret.Rpc)

		dst, err := format.Source([]byte(source.Bytes()))
		if err != nil {
			panic(err)
		}

		p.src_request_golang = string(dst)
	}()

	func() { // request csharp

		for i, v := range p.ret.Rpc {
			p.ret.Rpc[i].Name = trim_response_name_suffix(v.Name)
			p.ret.Rpc[i].Inherit = parse_inherit(v.Name)
			p.ret.Rpc[i].Override1 = parse_override1(v.Name)

			for j, w := range v.Fields {
				p.ret.Rpc[i].Fields[j].CsharpFieldDef = parse_go_struct_field_to_csharp_class_field(w.Type, w.Name)
			}
		}

		tpl_txt := `/// Code generated by protocol.def.go; DO NOT EDIT.

using System.Collections.Generic;

namespace Network.sdk.Excalibur.Protocol
{
{{range .}}    public sealed class {{.Name}} : {{.Inherit}}
    {
		{{.Override1}}
{{range .Fields}}    {{.CsharpFieldDef}}
{{end}}    }

{{end}}}
`
		tpl, e := template.New("request_csharp").Parse(tpl_txt)
		if e != nil {
			panic(e)
		}

		source := bytes.NewBuffer([]byte{})
		e = tpl.Execute(source, p.ret.Rpc)

		p.src_request_csharp = string(source.Bytes())
	}()

	func() { // rpc csharp

		tpl_txt := `/// Code generated by protocol.def.go; DO NOT EDIT.
namespace Network.sdk.Excalibur.Protocol
{
	public sealed partial class Msg
	{
		public static void deserialize_call(Msg.Code code, object s, object ctx)
		{
			string json = s.ToString();
			switch (code)
			{
				{{range .Msg.Fields}}case Msg.Code.{{.Name}}:
					{
						var ret = Msg.FromJson<{{.Name}}>(json);
						var f = ctx as rpc_callback<Ret<{{.Name}}>>;
						f(ret);
						break;
					}
					{{end}}
				default:
					{
						throw new System.Exception("Network: no such msg code: "+code.ToString());
					}
			}
		}
	}
}
`
		tpl, e := template.New("rpc_csharp").Parse(tpl_txt)
		if e != nil {
			panic(e)
		}

		source := bytes.NewBuffer([]byte{})
		e = tpl.Execute(source, p.ret)
		fmt.Println(string(source.Bytes()))

		p.src_rpc_csharp = string(source.Bytes())
	}()

	return p.ret
}
